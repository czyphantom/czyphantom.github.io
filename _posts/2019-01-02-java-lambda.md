---
layout:     post
title:      Java 8新特性
subtitle:   函数式编程
date:       2019-01-02
author:     CZY
header-img: img/bg.png
catalog: true
tags:
    - Java
---

## 基本概念

在Java 8中，由java.util.function包来表示函数。Function<T, R>表示接受一个参数的函数，输入类型为T，输出类型为R。Function接口只包含一个抽象方法R apply(T t)，也就是在类型为T的输入t上应用该函数，得到类型为R的输出。除了接受一个参数的Function之外，还有接受两个参数的接口BiFunction<T, U, R>，T和U分别是两个参数的类型，R是输出类型。BiFunction接口的抽象方法为R apply(T t, U u)。超过2个参数的函数在Java标准库中并没有定义。如果函数需要3个或更多的参数，可以使用第三方库。

除了 Function 和 BiFunction 之外，Java 标准库还提供了几种特殊类型的函数：
+ Consumer<T>：接受一个输入，没有输出。抽象方法为 void accept(T t)。
+ Supplier<T>：没有输入，一个输出。抽象方法为 T get()。
+ Predicate<T>：接受一个输入，输出为 boolean 类型。抽象方法为 boolean test(T t)。
+ UnaryOperator<T>：接受一个输入，输出的类型与输入相同，相当于 Function<T, T>。
+ BinaryOperator<T>：接受两个类型相同的输入，输出的类型与输入相同，相当于 BiFunction<T,T,T>。
+ BiPredicate<T, U>：接受两个输入，输出为boolean类型。抽象方法为 boolean test(T t, U u)。

在函数式编程中，函数可以作为另一个函数的输入，也可以作为另一个函数的输出，这种函数被称为高阶函数，高阶函数可以使得函数得到复用。函数式编程中只能有一个输入，但是可以通过柯里化将多个输入的函数转换为只有一个输入的函数，例如(x, y) -> x + y经过柯里化之后就是x -> (y -> x + y)。

闭包：当一个函数作为返回值，并且该函数内部使用了出现在其所在函数的词法域（lexical scope）的自由变量时，就创建了一个闭包。闭包的生命周期长于创建它的函数，因此，自由变量不能在堆栈上分配；否则一旦函数退出，自由变量就无法继续访问。因此，闭包所访问的自由变量必须在堆上分配。也正因为如此，支持闭包的编程语言都有垃圾回收机制，来保证闭包所访问的变量可以被正确地释放。同样，不正确地使用闭包可能造成潜在的内存泄漏。在Java中有与闭包类似的概念，那就是匿名内部类。在匿名内部类中，可以访问词法域中声明为 final 的变量。不是 final 的变量无法被访问，会出现编译错误。匿名内部类提供了一种方式来共享局部变量。不过并不能对该变量的引用进行修改。

## lamda表达式

简单来说，Lambda表达式是创建匿名内部类的语法糖。Java 8中，仅有一个抽象方法的接口为函数式接口，函数式接口的特别之处在于其实例可以通过Lambda表达式或方法引用来创建。Java 8的java.util.function包中添加了很多新的函数式接口。如果一个接口被设计为函数式接口，应该添加@FunctionalInterface注解。编译器会确保该接口确实是函数式接口。当尝试往该接口中添加新的方法时，编译器会报错。

Lambda表达式没有类型信息。一个Lambda表达式的类型由编译器根据其上下文环境在编译时刻推断得来。举例来说，Lambda表达式() -> System.out.println("Hello World!")可以出现在任何要求一个函数式接口实例的上下文中，只要该函数式接口的唯一方法不接受任何参数，并且返回值是void。由于Lambda表达式的类型由目标类型确定，在可能出现歧义的情况下，可能有多个类型满足要求，编译器无法独自完成类型推断。这个时候需要对代码进行改写，以帮助编译器完成类型推断。一个常见的做法是显式地把Lambda表达式赋值给一个类型确定的变量。另外一种做法是显示的指定类型。

在Lambda表达式的主体中，经常需要引用来自包围它的上下文环境中的变量。Lambda表达式使用一个简单的策略来处理主体中的名称解析问题。Lambda表达式并没有引入新的命名域（scope）。Lambda表达式中的名称与其所在上下文环境在同一个词法域中。Lambda 表达式在执行时，就相当于是在包围它的代码中。在Lambda表达式中的this也与包围它的代码中的含义相同。

## 流Stream

Java 8中的流表示的是元素的序列。流作为一个高层次的抽象，并不关注流中元素的来源或是管理方式。流只关注对流中元素所进行的操作。

### 顺序执行和 并行执行

流的操作可以顺序执行或并行执行, 后者可以获得比前者更好的性能。但是如果实现不当，可能由于数据竞争或无用的线程同步，导致并行执行时的性能更差。一个流是否会并行执行，可以通过其方法isParallel()来判断。根据流的创建方式，一个流有其默认的执行方式。可以使用方法sequential()或parallel()来将其执行方式设置为顺序或并行。

### 相遇顺序

一个流的相遇顺序（encounter order）是流中的元素被处理时的顺序。流根据其特征可能有，也可能没有一个确定的相遇顺序。举例来说，从ArrayList创建的流有确定的相遇顺序；从HashSet创建的流没有确定的相遇顺序。大部分的流操作会按照流的相遇顺序来依次处理元素。如果一个流是无序的，同一个流处理流水线在多次执行时可能产生不一样的结果。比如Stream的findFirst()方法获取到流中的第一个元素。如果在从ArrayList创建的流上应用该操作，返回的总是第一个元素；如果是从HashSet创建的流，则返回的结果是不确定的。对于一个无序的流，可以使用sorted操作来排序；对于一个有序的流，可以使用unordered()方法来使其无序。

### Spliterator

所有的流都是从Spliterator创建出来的。Spliterator的名称来源于它所支持的两种操作：split和iterator。Spliterator可以看成是Iterator的并行版本，允许通过对流中元素分片的方式来切分数据源。使用其tryAdvance方法来顺序遍历元素，也可以使用trySplit方法来创建一个新的Spliterator对象在新划分的数据集上工作。Spliterator还提供了forEachRemaining方法进行批量顺序遍历。可以使用estimateSize方法来查询可能会遍历的元素数量。一般的做法是先使用trySplit切分数据源。当元素数量足够小时，使用forEachRemaining来对分片中的全部元素进行处理。Spliterator需要绑定到流之后才能遍历其中的元素。不同的Spliterator实现可能有不同的绑定时机。如果一个Spliterator是延迟绑定的，那么只有在进行首次遍历、首次切分或首次查询大小时，才会绑定到流上；反之，它会在创建时或首次调用任何方法时绑定到流上。绑定时机的重要性在于，在绑定之前对流所做的修改，在Spliterator遍历时是可见的。延迟绑定可以提供最大限度的灵活性。

### 有状态和无状态操作

流操作可以是有状态或无状态的。当一个有状态的操作在处理一个元素时，它可能需要使用处理之前的元素时保留的信息；无状态的操作可以独立处理每个元素，举例来说：

+ distinct和sorted是有状态操作的例子。distinct操作从流中删除重复元素，它需要记录下之前已经遇到过的元素来确定当前元素是否应该被删除。sorted 操作对流进行排序，它需要知道所有元素来确定当前元素在排序之后的所在位置。
+ filter和map是无状态操作的例子。filter操作在进行过滤时只需要看当前元素即可。map操作可以独立转换当前元素。一般来说，有状态操作的运行代价要高于无状态操作，因为需要额外的空间保存中间状态信息。

Stream<T> 是表示流的接口，T是流中元素的类型。对于原始类型的流，可以使用专门的类IntStream、LongStream和DoubleStream。

### 流水线

在对流进行处理时，不同的流操作以级联的方式形成处理流水线。一个流水线由一个源（source），0到多个中间操作和一个终结操作完成。

源：源是流中元素的来源。Java 提供了很多内置的源，包括数组、集合、生成函数和 I/O 通道等。
中间操作：中间操作在一个流上进行操作，返回结果是一个新的流。这些操作是延迟执行的。
终结操作：终结操作遍历流来产生一个结果或是副作用。在一个流上执行终结操作之后，该流被消费，无法再次被消费。
流的处理流水线在其终结操作运行时才开始执行。

#### 源

Java 8 支持从不同的源中创建流。Stream.of方法可以使用给定的元素创建一个顺序流，集合也提供stream()方法创建一个流。

#### 中间操作

流中间操作在应用到流上，返回一个新的流。下面列出了常用的流中间操作：

+ map：通过一个Function把一个元素类型为T的流转换成元素类型为R的流。
+ flatMap：通过一个Function把一个元素类型为T的流中的每个元素转换成一个元素类型为 R 的流，再把这些转换之后的流合并。
+ filter：过滤流中的元素，只保留满足由Predicate所指定的条件的元素。
+ distinct：使用 equals 方法来删除流中的重复元素。
+ limit：截断流使其最多只包含指定数量的元素。
+ skip：返回一个新的流，并跳过原始流中的前 N 个元素。
+ sorted：对流进行排序。
+ peek：返回的流与原始流相同。当原始流中的元素被消费时，会首先调用 peek 方法中指定的 Consumer 实现对元素进行处理。
+ dropWhile：从原始流起始位置开始删除满足指定 Predicate 的元素，直到遇到第一个不满足 Predicate 的元素。
+ takeWhile：从原始流起始位置开始保留满足指定 Predicate 的元素，直到遇到第一个不满足 Predicate 的元素。

#### 终结操作

终结操作产生最终的结果或副作用。下面是一些常见的终结操作。

+ forEach和forEachOrdered对流中的每个元素执行由Consumer给定的实现。在使用forEach时，并没有确定的处理元素的顺序；forEachOrdered则按照流的相遇顺序来处理元素，如果流有确定的相遇顺序的话。

+ reduce操作把一个流约简成单个结果。约简操作可以有3个部分组成：

初始值：在对元素为空的流进行约简操作时，返回值为初始值。
叠加器：接受2个参数的BiFunction。第一个参数是当前的约简值，第二个参数是当前元素，返回结果是新的约简值。
合并器：对于并行流来说，约简操作可能在流的不同部分上并行执行。合并器用来把部分约简结果合并为最终的结果。


操作collect表示的是另外一类的约简操作。与reduce不同在于，collect会把结果收集到可变的容器中，如List或Set。收集操作通过接口java.util.stream.Collector来实现。Java已经在类Collectors中提供了很多常用的Collector实现。第一类收集操作是收集到集合中，常见的方法有toList()、toSet()和toMap()等。第二类收集操作是分组收集，即使用groupingBy对流中元素进行分组。分组时对流中所有元素应用同一个Function。具有相同结果的元素被分到同一组。分组之后的结果是一个Map，Map的键是应用Function之后的结果，而对应的值是属于该组的所有元素的List。

## 参考文章

[深入理解Java函数式编程](https://www.ibm.com/developerworks/cn/java/j-understanding-functional-programming-1/index.html?ca=drs-)